---
title: "프로그래머스 - 징검다리"
subtitle: "프로그래머스 - 징검다리"
categories:
  - 코딩테스트
tags:
  - BinarySearch
  - 코딩테스트
classes: wide
---

## 들어가며

오늘 풀어 볼 문제는 프로그래머스에 게시되어있는 **징검다리** 문제 입니다.

이진 탐색 알고리즘에 대해 연습할 겸 풀기 시작한 문제인데 결국 포기하고 다른 분들의 훌륭한 풀이를 보고나서야 겨우 이해할 수 있었습니다.
심지어 이진 탐색 카테고리의 문제라 어떤 알고리즘을 사용해서 풀어야 하는지도 알고 있었는데 말이죠...😭

혹시나 저와 같은 고생을 하실 분 들을 위해 풀이에 대해 정리해보려고 합니다👏🏻

#### 알고리즘 개념 참고 자료(Javascript)

[탐색 알고리즘 - 이진 탐색(Binary Search)](https://cjh5414.github.io/binary-search/)

## 문제

#### 프로그래머스 코딩테스트 연습 - 징검다리

[https://programmers.co.kr/learn/courses/30/lessons/43236](https://programmers.co.kr/learn/courses/30/lessons/43236)

## 접근 방식

### 첫 시도

처음 문제를 읽었을 때는 "이 문제가 왜 이진 탐색 문제인거지?" 라는 생각이 들었습니다.  
그리고 이런 풀이 방법을 떠올렸죠🤖

1. `rocks`에서 n개를 뽑을 수 있는 모든 조합을 구한다
2. 각 조합에 해당하는 돌을 제거했을 때, 간격의 최솟값을 구한다.
3. 최솟값들 중 최대값을 구해 반환한다.

우선 이런 로직으로 짠 코드를 제출했고 대차게 실패했습니다. 답을 정확하게 구할 수 있는 방법이었지만 실행 시간이 너무 오래 걸리는 방법이었거든요....🙅‍♂️

### 이진 탐색

이 문제를 이진 탐색으로 풀기 위해선 문제를 약간 다른 방식으로 바라봐야 합니다.

기존 방식처럼 모든 경우의 수에서 최솟값을 구하고 비교하는 것이 아니라,

**임의의 숫자**를 최솟값이라고 가정하고, 돌 간격의 최솟값이 이 **임의의 숫자**가 되기 위해선 몇 개의 돌을 제거해야 하는가?에 집중하는 겁니다!!😱

그리고 저희는 이 **임의의 숫자**를 이진 탐색으로 찾아가면 되는 것이죠ㅎ...(무슨 말이야...🐴)

너무 어렵죠...?🤯 저도 이해하기 너무 너무 어려웠습니다. 아직 포기하지 마세요!  
이제 실제 코드와 로직을 각 단계별로 구별해서 살펴볼게요.

### 구현 코드

```javascript
function solution(distance, rocks, n) {
  let answer = 0;
  rocks.sort((a, b) => a - b);
  BSearch(1, distance);
  return answer;

  function BSearch(min, max) {
    if (min > max) {
      return;
    }

    let cnt = 0;
    let prev = 0;
    let mid = Math.floor((min + max) / 2);
    for (let rock of rocks) {
      if (rock - prev < mid) {
        cnt++;
      } else {
        prev = rock;
      }
    }

    if (distance - prev < mid) {
      cnt++;
    }
    if (cnt <= n) {
      answer = answer > mid ? answer : mid;
      return BSearch(mid + 1, max);
    } else {
      return BSearch(min, mid - 1);
    }
  }
}
```

문제에서 예시로 주어진 상황을 살펴보겠습니다.(괄호안의 숫자는 돌의 위치를 의미합니다)

`1 (2) 3 4 5 6 7 8 9 10 (11) 12 13 (14) 15 16 (17) 18 19 20 (21) 22 23 24 25`

**mid 는 위에서 말한 임의의 수로 우리가 최솟값으로 가정한 수 입니다**

1. 주어진 `rocks`를 오름차순으로 정렬
2. `min = 1`, `max = 25`, `prev = 0`로 설정하고 이진 탐색을 시작  
   2-2. `prev`에는 간격을 비교할 돌의 위치를 기록
3. 임의의 숫자 `mid`를 구한다. `(min + max)/2`
4. `rocks`를 순회하며 각 돌과 `prev`의 간격을 계산  
   4-1. 간격이 `mid` 보다 **작은** 경우 `count`를 1 증가 시킨다.  
   4-2. 간격이 `mid` 보다 **크거나 같은** 경우 해당 돌을 `prev`에 기록한다.
5. `distance`와 마지막에 기록된 `prev`의 간격도 계산하여 3 단계와 같은 로직으로 `count`를 설정
6. `count`가 `n` 보다 작거나 같다면 `min = mid +1`, `max = max`로 설정하고 현재 `mid` 값과 `answer`를 비교하여 큰 값을 `answer`에 저장하고, 1 단계 부터 다시 진행  
   6-1. `count`가 `n` 보다 크다면 `min = min`, `max = mid-1`로 설정하여 1 단계 부터 다시 진행

위와 같이 구현하면 정답이 나옵니다. 그럼 이제 왜 이렇게 구현한 것인지 이유를 알아보겠습니다.

### 로직 설명

위 로직에서 가장 중요한 것은 4번과 6번 단계를 이해하는 것입니다.
왜 mid 값을 기준으로 count를 증가시키고, count를 기준으로 이진 탐색의 범위를 설정하는 걸까요?😬

4번 단계는 현재 최솟값이라고 가정하고 있는 임의의 수인 `mid`가 진짜 최솟값이 되도록 간격이 `mid`보다 작은 돌들을 제거하는 과정입니다..

즉, 간격이 우리가 가정한 최솟값보다 작도록 만드는 돌을 제거하여 남아있는 돌들의 위치가 모두 최솟값 **이상**이 되도록 만들어 주는 것이죠!(방해꾼☠️들을 제거하는 것이라고 이해하면 되겠네요)

#### 제거된 돌이 너무 많은 상황

예를 들어 `mid=13`일때, count가 증가하는 돌들이 제거됐다고(방해꾼 제거! 최솟값이 13이 되는 것을 방해하는 돌들 제거!) 가정하면 남아있는 돌은 아래와 같을 것이고,  
`1 (14) 25`  
돌들의 간격을 13으로 만들기 위해선 5개나 돌을 제거 해야 한다는 것이기 때문에 우리가 설정한 최솟값이 너무 크다는 것을 의미합니다.
(우리는 돌을 2개만 제거하고 싶으니까요😲)

그렇다면 우리가 생각한 최솟값을 줄여서 설정해야겠죠??(6-1 단계를 진행합니다)

#### 제거된 돌이 너무 적은 상황

반대로 `mid=3`인 상황을 예로들어 보겠습니다.
똑같이 count가 증가하는 돌들이 제거됐다고 가정한다면, 돌의 상태는 이렇습니다.  
`1 (11) (14) (17) (21) 25`  
2번 돌이 제거 된다면 충분히 최솟값을 3으로 만들 수 있는 상황이죠👍🏻

즉, 2번 돌을 제외한 모든 돌의 간격이 우리가 가정한 최솟값 **이상**이 되므로, 2외의 어떤 돌 1개를 제거했을 때 간격의 최솟값을 2로 유지할 수 있는 것을 의미합니다.

그런데 여기서 우리는 최솟값들 중 최대값을 찾아야 하므로 최솟값이 3보다 큰 상황에서도 조건을 만족할 수 있는지를 알아보기 위해 최솟값을 더 크게 설정하여 다시 탐색하는 단계가 필요합니다.(6번 단계를 진행합니다)

#### 제거된 돌이 없는 경우??

한가지의 예만 더 살펴보겠습니다.🤢  
`mid=2` 일 때, 로직에 의하면 제거되어야 하는 돌은 없습니다.
이것은 돌들을 제거하고 난 상태에서 어떤 조건만 만족하면(2번 돌을 제외한 나머지 돌들 중 2개를 제거) 충분히 최솟값을 2로 만들 수 있다는 것을 의미하므로 **제거된 돌이 너무 적은 상황**과 같습니다.

---

이렇게 최솟값이 너무 클 때는 작은 범위를 탐색하고, 최솟값을 만족할 때는 조금더 큰 최솟값이 있는지 큰 범위를 탐색하며 **가장 큰 최솟값**을 찾아갑니다

> 포인트는 임의의 수를 최솟값으로 가정하고 그 임의의 숫자가 진짜 최솟값이 될 수 있도록 돌을 제거해 보는 겁니다. 그리고 제거한 돌의 숫자가 주어진 n 이하라면 '더 큰 최솟값은 없을까?'라는 의심을 품고 더 큰 범위를 탐색하는 것이죠!

## 나가며

너무 어렵습니다😩 진짜루요...  
다른 분들의 풀이를 보고 하루 종일 분석을 한 후에야 겨우 이해를 했거든요...  
심지어 이 글을 쓰고있는 지금도 순간순간 왜 이렇게 하는 거지? 라는 생각이 들더라구요👻
그래서 더더욱 정리하고 넘어가야겠다라는 생각이 든 문제였습니다.

과연 이 문제가 이진 탐색 카테고리에 있다는 것을 몰랐다면 이진 탐색으로 풀 생각을 혼자 할 수 있었을까 라는 생각이 머리를 떠나지 않네요!

역시 아직 갈 길이 먼 것 같습니다. 화이팅👏🏻

## 참고

- [https://taesan94.tistory.com/154](https://taesan94.tistory.com/154)
- [https://velog.io/@hyeon930/프로그래머스-징검다리-Java](https://velog.io/@hyeon930/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC-Java)
